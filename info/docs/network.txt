
Object types

scripts, abstractions, and recorders
there is also a required snippet of input/output messaging objects at the top level of the patcher.
they are the only objects with no outputs/inputs, respectively. 

these objects represent nodes in a digraph, with each node contributing to the total amount of vertices in the graph 
based on it's outlets and inlets

node objects are any abstractions that do not involve the file system 

script objects are abstractions that revolve around the qlist max object.
they can read the text/json files generated by any systems

recorder objects are max objects that revolve around objects that can write media to disk.
they can write any type of data 
they include:
video: jit.vcr~
audio: sfrecord~
image: jit.matrix
multitrackevent: mtr
midi: detonate

the network itself is defined by these objects 
and a connection matrix, with width = number of node outlets, and height = number of node inlets 

to send the correct scripting messages, the 









Objects
global object nane is
<experimentID>_<interpretationID>_<fileIndex>
global filename  is the object name + the file extension
objects: 

Global
Data objects
	⁃	create with name and args
	⁃	create, connect to “; NETWORK next”
 buffer~, dict, jit.matrix 
 coll, table: read, then name

Gl objects 
	⁃	in a global-ctx context
material, texture, pass, shader
Gen objects 

(gen) gen/gen~/jit.gen/jit.pix/jit.gl.pix 

Local 
autoread
	⁃	created with filename
text, funbuff, filein, seq, js
manual read
	⁃	send read message on load
(read) seq~, model, qlist
Scripted 
	⁃	send script newobject and connect to associated send/receives 
poly~/pfft~/patcher/node.script
Media
	⁃	previously created media files
	⁃	script then read from recent media file in experimentID
mc.sfplay~, jit.movie~

Dict Target Objects
Filter
cascade~, biquad~ etc…
MatrixCtrl
matrix~, mc.matrix~, matrixctrl, 
Timestretch
groove~, sfplay~, stretch~
Miscellaneous 
mtr, live.step, mc.pattern~, mc.chord~, umenu
You sent
Objects
global object nane is
<experimentID>_<interpretationID>_<fileIndex>
global filename  is the object name + the file extension
objects: 

Global
Data objects
	⁃	create with name and args
	⁃	create, connect to “; NETWORK next”
 buffer~, dict, jit.matrix 
 coll, table: read, then name

Gl objects 
	⁃	in a global-ctx context
material, texture, pass, shader
Gen objects 

(gen) gen/gen~/jit.gen/jit.pix/jit.gl.pix 

Local 
autoread
	⁃	created with filename
text, funbuff, filein, seq, js
manual read
	⁃	send read message on load
(read) seq~, model, qlist
Scripted 
	⁃	send script newobject and connect to associated send/receives 
poly~/pfft~/patcher/node.script
Media
	⁃	previously created media objects
	⁃	script then read from recent media file in experimentID
mc.sfplay~, jit.movie~

Dict Target Objects
Filter
cascade~, biquad~ etc…
MatrixCtrl
matrix~, mc.matrix~, matrixctrl, 
Timestretch
groove~, sfplay~, stretch~
Miscellaneous 
mtr, live.step, mc.pattern~, mc.chord~, umenu, textedit






// script goes like this:


//  // set the network timeout
// for each media file
//      for each patcher in media
//           if patcher was not present in previous file
//                script open patcher
//                for each global_object in the patcher
//                    get the associated format and constructed filename from the interpreter 
//                    script a new object
//                    script a connection to the objectResponder (send a next message on file load) 
//                    script a read message to the object  
//                    store the interpretation's experimentOutput filepath and set the associated localPatcher filepath to null
//               send all global names 
//               for each local_object 
//                    get the associated format and constructed filename from the interpreter 
//                    set the associated localPatcher filepath
//      script the new media object
//      connect the media object to the appropriate global signals
//      script the open message to the media object
//      set the media timeout 
//      script the global start message
//      script any other messages
//      script the global stop message
//      for each patcher in media
//          if patcher not present in the next file
//              script close the patcher
//              for each global_object in the patcher
//                  script remove the global object
//      
//      script remove the media object
// on last media file, output the global complete event
// 